## Part 4: Invoking OCaml Functions from Rust

The [`ocaml!`] macro is used to declare Rust bindings for OCaml functions.

### 4.1 The [`ocaml!`] Macro

This macro defines Rust function bindings for OCaml functions that have been registered on the
OCaml side using `Callback.register "ocaml_function_name" ocaml_function_name`.

**Example:**

Suppose you have the following OCaml code:
```ocaml
(* In your OCaml library, e.g., my_ocaml_lib.ml *)
let greet name = Printf.printf "Hello, %s!\n" name
let add_ints a b = a + b

let () =
  Callback.register "ml_greet" greet;
  Callback.register "ml_add_ints" add_ints
```

To call these from Rust, you would declare them using the [`ocaml!`] macro:

```rust
mod ocaml_api {
    use ocaml_interop::{ocaml, OCamlInt};

    ocaml! {
        // OCaml: val ml_greet : string -> unit
        // Effective Rust signature generated:
        //   pub fn ml_greet(cr: &mut OCamlRuntime, name: OCamlRef<String>);
        pub fn ml_greet(name: String);

        // OCaml: val ml_add_ints : int -> int -> int
        // Effective Rust signature generated:
        //   pub fn ml_add_ints(cr: &mut OCamlRuntime, a: OCamlRef<OCamlInt>, b: OCamlRef<OCamlInt>) -> BoxRoot<OCamlInt>;
        pub fn ml_add_ints(a: OCamlInt, b: OCamlInt) -> OCamlInt;
    }
}
```

Key points about the [`ocaml!`] macro usage:
-   The macro generates Rust functions (e.g., `ocaml_api::ml_greet(cr, ...)` and
    `ocaml_api::ml_add_ints(cr, ...)`).
-   The first argument to these generated Rust functions is automatically [`cr: &mut OCamlRuntime`](OCamlRuntime),
    even if not explicitly listed in the `ocaml!{}` block for a given function signature.
-   **Flexible Parameters**: Arguments accept both [`OCamlRef<T>`](OCamlRef) references and direct Rust values
    convertible to OCaml. You can pass either `&boxroot_value` or `direct_rust_value`.
-   Return types specified in `ocaml!{}` (e.g., `-> OCamlInt`) indicate the type contained
    within the [`BoxRoot<T>`](BoxRoot) that the generated Rust function will return.

### 4.2 Passing Arguments to OCaml

-   **Flexible Parameters**: Functions generated by [`ocaml!`] can accept either direct Rust values
    (like `42`, `"hello"`, `vec![1,2,3]`) or [`OCamlRef<'a, T>`](OCamlRef) references (like `&boxroot`).
-   When passing direct Rust values, they are automatically converted to OCaml using [`ToOCaml`].
-   When passing [`OCamlRef<'a, T>`](OCamlRef) references, they are used directly without conversion.
-   [`OCamlRef<'a, T>`](OCamlRef) can be obtained from [`OCaml<'gc, T>`](OCaml) or [`BoxRoot<T>`](BoxRoot) using `&`.

#### 4.2.1 Using Direct Rust Values (Recommended for Simple Cases)

```rust
# use ocaml_interop::{OCamlRuntime, ocaml, OCamlInt, OCamlRuntimeStartupGuard};
# mod ocaml_api {
#     use ocaml_interop::{ocaml, OCamlInt};
#     ocaml! { pub fn add_ints(a: OCamlInt, b: OCamlInt) -> OCamlInt; }
#     ocaml! { pub fn greet(name: String); }
# }
# fn test() -> Result<(), String> {
# let _guard: OCamlRuntimeStartupGuard = OCamlRuntime::init()?;
OCamlRuntime::with_domain_lock(|cr| {
    // Pass direct Rust values - they're automatically converted
    let result = ocaml_api::add_ints(cr, 42, 37);
    let sum: i64 = result.to_rust(cr);

    // Works with strings too
    ocaml_api::greet(cr, "World");

    // Or string references
    let name = "Alice".to_string();
    ocaml_api::greet(cr, &name);
});
# Ok(())
# }
```

#### 4.2.2 Using OCamlRef Arguments (For Complex Scenarios)

-   **Role of the Borrow Checker**: `ocaml-interop` leverages Rust's borrow checker. An
    [`OCaml<'gc, T>`](OCaml) value is tied to the lifetime (`'gc`) of the [`OCamlRuntime`] reference (`cr`)
    from which it was obtained or with which it is associated. If an operation occurs that
    mutably borrows `cr` (e.g., another call into OCaml, allocation), the borrow checker will
    prevent the use of pre-existing [`OCaml<'gc, T>`](OCaml) values that might have been invalidated by
    potential GC activity. This is a key safety feature.
-   **When to Use [`BoxRoot<T>`](BoxRoot) for Arguments (and the Borrow Checker)**:
    The primary reason for explicitly using [`BoxRoot<T>`](BoxRoot) for arguments when calling OCaml functions
    (defined via [`ocaml!`]) stems from Rust's borrow checking rules interacting with the
    [`&mut OCamlRuntime`](OCamlRuntime) requirement of these functions.

    1.  **The [`&mut OCamlRuntime`](OCamlRuntime) Conflict**: Functions generated by [`ocaml!`] take `cr: &mut OCamlRuntime`
        as their first, implicit argument. If you create a temporary, unrooted OCaml value like
        `let ocaml_arg = rust_data.to_ocaml(cr);`, this `ocaml_arg` (of type [`OCaml<'gc, T>`](OCaml))
        holds an immutable borrow on `cr` for its lifetime `'gc`. When you then attempt to call
        an OCaml function, e.g., `ocaml_api::some_func(cr, &ocaml_arg)`, a borrow conflict arises:
        `some_func` requires a mutable borrow of `cr`, but `ocaml_arg` still immutably borrows it.
        Rust's borrow checker will prevent this.

    2.  **`BoxRoot<T>` as the Workaround**: Converting the Rust data to a [`BoxRoot<T>`](BoxRoot) using
        `let ocaml_arg_rooted = rust_data.to_boxroot(cr);` resolves this. A [`BoxRoot<T>`](BoxRoot)
        registers the OCaml value with the GC independently. Its validity is not tied to the
        specific borrow of `cr` used for its creation in the same way an [`OCaml<'gc, T>`](OCaml) is.
        Thus, you can pass [`&mut OCamlRuntime`](OCamlRuntime) to the OCaml function and pass `&ocaml_arg_rooted`
        (which becomes an [`OCamlRef<T>`](OCamlRef)) without a borrow checker conflict.

    3.  **In Practice**: This pattern is mainly needed when you need to store OCaml values longer-term
        or when the borrow checker prevents using direct values. For simple cases, direct Rust values
        are easier and recommended.

```rust
# use ocaml_interop::{OCamlRuntime, ToOCaml, BoxRoot, OCamlRef, OCamlFloat, OCamlRuntimeStartupGuard};
# mod ocaml_api {
#     use ocaml_interop::{ocaml, OCamlFloat, OCamlRuntime, BoxRoot, OCamlRef};
#     ocaml! { pub fn add_floats(a: OCamlFloat, b: OCamlFloat) -> OCamlFloat; }
# }
# fn test() -> Result<(), String> {
# let _guard: OCamlRuntimeStartupGuard = OCamlRuntime::init()?;
OCamlRuntime::with_domain_lock(|cr| {
    let val_a_rust: f64 = 5.5;
    let val_b_rust: f64 = 2.3;

    // Option 1: Use direct values (recommended for simple cases)
    let sum_ocaml: BoxRoot<OCamlFloat> = ocaml_api::add_floats(cr, val_a_rust, val_b_rust);
    let sum_rust: f64 = sum_ocaml.to_rust(cr);
    println!("Sum using direct values: {sum_rust}");

    // Option 2: Use BoxRoot when needed for complex scenarios
    let val_a_ocaml: BoxRoot<OCamlFloat> = val_a_rust.to_boxroot(cr);
    let val_b_ocaml: BoxRoot<OCamlFloat> = val_b_rust.to_boxroot(cr);
    let sum_ocaml: BoxRoot<OCamlFloat> = ocaml_api::add_floats(cr, &val_a_ocaml, &val_b_ocaml);
    let sum_rust: f64 = sum_ocaml.to_rust(cr);
    println!("Sum using BoxRoot: {sum_rust}");
});
# Ok(())
# }
```

### 4.3 Receiving Return Values from OCaml

-   Functions declared using [`ocaml!`] that return a value will yield a [`BoxRoot<T>`](BoxRoot).
-   This ensures that the returned OCaml value is immediately rooted and thus safe for use
    within Rust.
-   It can subsequently be converted to a Rust type using `.to_rust(cr)`.

### 4.4 Handling OCaml Exceptions from Rust

-   If an OCaml function invoked from Rust raises an exception, this will currently manifest as
    a **Rust panic**.
-   **Recommendation:** It is advisable to design OCaml functions intended for FFI with Rust to
    signal error conditions by returning `option` or `result` types (e.g., `int option`,
    `(string, string) result`), rather than by raising exceptions. These can then be mapped to
    Rustâ€™s `Option<T>` and `Result<T, E>` types.
